{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Travel-time isochrones with Mapbox, Python, and GeoPandas\"\n",
        "author: \"Kyle Walker\"\n",
        "date: \"2023-08-10\"\n",
        "categories: [python, gis, data science, navigation]\n",
        "image: image.png\n",
        "editor: \n",
        "  markdown: \n",
        "    wrap: 72\n",
        "---\n",
        "\n",
        "_Travel-time isochrones_ are powerful analytical tools that represent the reachable area from a location for a given time and travel mode.  In R, my package [mapboxapi](https://walker-data.com/mapboxapi) seamlessly integrates with R's GIS infrastructure to allow for the use of Mapbox's isochrones in spatial analysis workflows.  In Python, there isn't a package that directly connects [Mapbox's navigation toolkit](https://docs.mapbox.com/api/navigation/) to GeoPandas for spatial data analysis.  However, these services _are_ accessible via the [routingpy Python package](https://routingpy.readthedocs.io/en/latest/).  \n",
        "\n",
        "In this blog post, I'll present a workflow to help you connect GeoPandas with Mapbox's isochrone services via routingpy.  You'll be able to use GeoPandas POINT geometries as inputs and get back isochrone polygons as GeoDataFrames.  The goal is to replicate some of the functionality of R's `mb_isochrone()` function in Python.\n",
        "\n",
        "To get started, let's import a few libraries we'll need, and make a connection to Mapbox's navigation services which are named `MapboxOSRM` in routingpy.  You'll need a Mapbox account and a Mapbox access token to get this to work; you get 100,000 isochrones for free each month, so you shouldn't have to worry about getting charged.  "
      ],
      "id": "f00aa6a9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "import geopandas as gp\n",
        "import pandas as pd\n",
        "from shapely.geometry import Polygon\n",
        "from routingpy.routers import MapboxOSRM\n",
        "import numpy as np\n",
        "\n",
        "mb = MapboxOSRM(api_key = \"pk.eyJ1Ijoia3dhbGtlcnRjdSIsImEiOiJMRk9JSmRvIn0.l1y2jHZ6IARHM_rA1-X45A\")"
      ],
      "id": "064bbcda",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "import geopandas as gp\n",
        "import pandas as pd\n",
        "from shapely.geometry import Polygon\n",
        "from routingpy.routers import MapboxOSRM\n",
        "import numpy as np\n",
        "\n",
        "mb = MapboxOSRM(api_key = \"YOUR KEY GOES HERE\")"
      ],
      "id": "f77d6bab",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let's use a public libraries dataset in the city of Dallas, Texas as an example.  Mapbox's routing services will run for any location in the world covered by OpenStreetMap, so you can try this out for other datasets of interest as well.  "
      ],
      "id": "56a6cd96"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dallas_libraries = gp.read_file(\"https://egis.dallascityhall.com/resources/Downloads/ShpZip/Library/Libraries.zip\")\n",
        "\n",
        "dallas_libraries.explore()"
      ],
      "id": "94e5bba3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next comes the `mb_isochrone()` function.  I've written this to work in a similar way to `mb_ischrone()` in R, though it is much more limited.  Read through the comments in the code to get a sense of how it works.  \n"
      ],
      "id": "12509783"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def mb_isochrone(gdf, time = [5, 10, 15], profile = \"driving\"):\n",
        "\n",
        "    # Grab X and Y values in 4326\n",
        "    gdf['LON_VALUE'] = gdf.to_crs(4326).geometry.x\n",
        "    gdf['LAT_VALUE'] = gdf.to_crs(4326).geometry.y\n",
        "\n",
        "    coordinates = gdf[['LON_VALUE', 'LAT_VALUE']].values.tolist()\n",
        "\n",
        "    # Build a list of shapes\n",
        "    isochrone_shapes = []\n",
        "\n",
        "    if type(time) is not list:\n",
        "        time = [time]\n",
        "\n",
        "    # Use minutes as input, but the API requires seconds\n",
        "    time_seconds = [60 * x for x in time]\n",
        "\n",
        "    # Given the way that routingpy works, we need to iterate through the list of \n",
        "    # coordinate pairs, then iterate through the object returned and extract the \n",
        "    # isochrone geometries.  \n",
        "    for c in coordinates:\n",
        "        iso_request = mb.isochrones(locations = c, profile = profile,\n",
        "                                    intervals = time_seconds, polygons = \"true\")\n",
        "\n",
        "        for i in iso_request:\n",
        "            iso_geom = Polygon(i.geometry[0])\n",
        "            isochrone_shapes.append(iso_geom)\n",
        "\n",
        "    # Here, we re-build the dataset but with isochrone geometries\n",
        "    df_values = gdf.drop(columns = ['geometry', 'LON_VALUE', 'LAT_VALUE'])\n",
        "\n",
        "    time_col = time * len(df_values)\n",
        "\n",
        "    # We'll need to repeat the dataframe to account for multiple time intervals\n",
        "    df_values_rep = pd.DataFrame(np.repeat(df_values.values, len(time_seconds), axis = 0))\n",
        "    df_values_rep.columns = df_values.columns\n",
        "\n",
        "    isochrone_gdf = gp.GeoDataFrame(\n",
        "        data = df_values_rep,\n",
        "        geometry = isochrone_shapes,\n",
        "        crs = 4326\n",
        "    )\n",
        "\n",
        "    isochrone_gdf['time'] = time_col\n",
        "\n",
        "    # We are sorting the dataframe in descending order of time to improve visualization\n",
        "    # (the smallest isochrones should go on top, which means they are plotted last)\n",
        "    isochrone_gdf = isochrone_gdf.sort_values('time', ascending = False)\n",
        "\n",
        "    return(isochrone_gdf)\n"
      ],
      "id": "ccbe3534",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let's try it out!  The function runs seamlessly over a dataset of 29 input points, returning 29 5-minute isochrones that we can visualize with `.explore()`.  "
      ],
      "id": "bce0b53d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "library_isos = mb_isochrone(dallas_libraries, time = 5, \n",
        "                            profile = \"driving-traffic\")\n",
        "\n",
        "library_isos.explore()"
      ],
      "id": "e0605d18",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "One feature the R version of `mb_isochrone()` includes is the ability to get isochrones directly from an address.  Here, we'll need to geocode the address first and pass it to `mb_isochrone()`.  Our result is an interactive map of multiple travel-times around our input address. "
      ],
      "id": "8030defe"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dickies = gp.tools.geocode(\"1911 Montgomery St, Fort Worth, TX 76107\")\n",
        "\n",
        "dickies_isos = mb_isochrone(dickies, time = [5, 10, 15], profile = \"driving-traffic\")\n",
        "\n",
        "dickies_isos.explore(column = \"time\")"
      ],
      "id": "ce01d5ec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "A great benefit of using isochrones with GeoPandas is that the isochrone shapes can be integrated into all sorts of spatial analysis workflows.  If you are interested in integrating isochrones into your application or business workflow, or if you'd like a custom workshop to help you get up and running with these tools, please don't hesistate to reach out to <kyle@walker-data.com>!\n"
      ],
      "id": "b73ffbbd"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/kylewalker/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}