{
  "hash": "0faf4d4f2cc5d9ac5b47710c1fa2a99d",
  "result": {
    "markdown": "---\ntitle: \"Analyzing labor markets in Python with LODES data\"\nauthor: \"Kyle Walker\"\ndate: \"2023-01-10\"\ncategories: [python, gis, data science]\nimage: image.png\neditor: \n  markdown: \n    wrap: 72\n---\n\nIn [Chapter 11 of my book *Analyzing US Census\nData*](https://walker-data.com/census-r/other-census-and-government-data-resources.html),\nI explore a sampling of the variety of government datasets that are\navailable for the United States. One of the most useful of these\ndatasets is [LODES (LEHD Origin-Destination Employment\nStatistics)](https://lehd.ces.census.gov/data/). LODES is a synthetic\ndataset that represents, down to the Census block level, job counts by\nworkplace and residence as well as the flows between them.\n\nGiven that LODES data are tabulated at the Census block level, analysts\nwill often want to merge the data to Census geographic data like what is\naccessible in the [**pygris** package](https://walker-data.com/pygris/).\n**pygris** includes a function, `get_lodes()`, that is modeled after the\nexcellent **lehdr** R package by [Jamaal Green, Dillon Mahmoudi, and\nLiming Wang](https://github.com/jamgreen/lehdr).\n\nThis post will illustrate how to analyze the origins of commuters to the\nCensus tract containing Apple's headquarters in Cupertino, CA. In doing\nso, I'll highlight some of the data wrangling utilities in **pandas**\nthat allow for the use of method chaining, and show how to merge data to\n**pygris** shapes for mapping. The corresponding section in *Analyzing\nUS Census Data* to this post is \"[Analyzing labor markets with\nlehdr](https://walker-data.com/census-r/other-census-and-government-data-resources.html#analyzing-labor-markets-with-lehdr).\"\n\n## Acquiring and wrangling LODES data\n\nTo get started, let's import the functions and modules we need and give\n`get_lodes()` a try. `get_lodes()` requires specifying a state (as state\nabbreviation) and year; we are getting data for California in 2019, the\nmost recent year currently available. The argument `lodes_type = \"od\"`\ntells **pygris** to get origin-destination flows data, and\n`cache = True` will download the dataset (which is nearly 100MB) to a\nlocal cache directory for faster use in the future.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom pygris import tracts \nfrom pygris.data import get_lodes\nimport matplotlib.pyplot as plt\n\nca_lodes_od = get_lodes(\n    state = \"CA\",\n    year = 2019,\n    lodes_type = \"od\",\n    cache = True\n)\n\nca_lodes_od.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>w_geocode</th>\n      <th>h_geocode</th>\n      <th>S000</th>\n      <th>SA01</th>\n      <th>SA02</th>\n      <th>SA03</th>\n      <th>SE01</th>\n      <th>SE02</th>\n      <th>SE03</th>\n      <th>SI01</th>\n      <th>SI02</th>\n      <th>SI03</th>\n      <th>createdate</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>060014001001007</td>\n      <td>060014001001044</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>20211018</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>060014001001007</td>\n      <td>060014001001060</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>20211018</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>060014001001007</td>\n      <td>060014038002002</td>\n      <td>1</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>20211018</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>060014001001007</td>\n      <td>060014041021003</td>\n      <td>1</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>20211018</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>060014001001007</td>\n      <td>060014042002012</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>20211018</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe loaded dataset, which has nearly 16 million rows, represents\nsynthetic origin-destination flows from Census block to Census block in\nCalifornia in 2019. Columns represent the [Census block\nGEOIDs](https://walker-data.com/census-r/an-introduction-to-tidycensus.html#understanding-geoids)\nfor both workplace and residence, as well as job counts for flows\nbetween them. `S000` represents all jobs; [see the LODES documentation\nfor how other breakouts are\ndefined](https://lehd.ces.census.gov/data/lodes/LODES7/LODESTechDoc7.5.pdf).\n\n16 million rows is a lot of data to deal with all at once, so we'll want\nto do some targeted data wrangling to make this more manageable. We'll\ndo so using a *method chain*, which is my preferred way to do data\nwrangling in Python given that I come from an R / tidyverse background.\nThe code takes the full origin-destination dataset, rolls it up to the\nCensus tract level, then returns (by Census tract) the number of\ncommuters to Apple's Census tract in Cupertino.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\napple = (\n    ca_lodes_od\n    .assign(w_tract = ca_lodes_od['w_geocode'].str.slice(stop = 11),\n            h_tract = ca_lodes_od['h_geocode'].str.slice(stop = 11))\n    .query('w_tract == \"06085508102\"')\n    .groupby('h_tract', as_index = False)\n    .agg({'S000': sum})\n    .rename({'S000': 'apple_workers'}, axis = 1)\n)\n\napple.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_tract</th>\n      <th>apple_workers</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>06001400100</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>06001400200</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>06001400300</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>06001400400</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>06001400500</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLet's step through how we did this:\n\n-   The `.assign()` method is used to calculate two new Census tract\n    columns. A great thing about Census GEOIDs is that child geographies\n    (like Census blocks) contain information about parent geographies.\n    In turn, we can calculate Census tract GEOIDs by slicing block\n    GEOIDs for the first 11 characters.\\\n-   `.query()` is used to subset our data. We only want rows\n    representing commuters to the Apple campus (or the area around it),\n    so we query for that specific tract ID.\n-   Next, we'll roll up our data to the tract level. We'll first group\n    the data by home Census tract with `.groupby()`, then calculate\n    group sums with `.agg()`.\\\n-   Finally, we use a dictionary passed to `.rename()` to give the jobs\n    column a more interpretable name.\n\nNext, we'll repeat this process to tabulate the *total number of\nworkers* by home Census tract to be used as a denominator. After that,\nwe can merge the Apple-area commuters dataset back in, and calculate a\nrate per 1000. Note the `lambda` notation used in the final step of the\nmethod chain: this allows us to refer to the dataset that is being\ncreated by the chain.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\napple_commuters = (\n    ca_lodes_od\n    .assign(h_tract = ca_lodes_od['h_geocode'].str.slice(stop = 11))\n    .groupby('h_tract', as_index = False)\n    .agg({'S000': sum})\n    .rename({'S000': 'total_workers'}, axis = 1)\n    .merge(apple, on = 'h_tract')\n    .assign(apple_per_1000 = lambda x: 1000 * (x['apple_workers'] / x['total_workers']))\n)\n\napple_commuters.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_tract</th>\n      <th>total_workers</th>\n      <th>apple_workers</th>\n      <th>apple_per_1000</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>06001400100</td>\n      <td>1412</td>\n      <td>3</td>\n      <td>2.124646</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>06001400200</td>\n      <td>1095</td>\n      <td>3</td>\n      <td>2.739726</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>06001400300</td>\n      <td>2650</td>\n      <td>3</td>\n      <td>1.132075</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>06001400400</td>\n      <td>2341</td>\n      <td>2</td>\n      <td>0.854336</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>06001400500</td>\n      <td>2147</td>\n      <td>4</td>\n      <td>1.863065</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Mapping commute flows to Apple headquarters\n\nThe main purpose of the **pygris** package is to make the acquisition of\nUS Census Bureau spatial data easy for Python users. Given that we have\naggregated our data at the Census tract level, we can use the `tracts()`\nfunction to grab Census tract shapes for six counties in the San\nFrancisco Bay Area. We'll use the Cartographic Boundary shapefiles with\n`cb = True` to exclude most water area, and make sure to specify\n`year = 2019` to match the 2019 LODES data.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nbay_tracts = tracts(state = \"CA\", cb = True,\n                    county = [\"San Francisco\", \"Alameda\", \"San Mateo\",\n                              \"Santa Clara\", \"Marin\", \"Contra Costa\"], \n                    year = 2019, cache = True)\n                    \nbay_tracts.plot()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUsing FIPS code '06' for input 'CA'\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nUsing FIPS code '075' for input 'San Francisco'\nUsing FIPS code '001' for input 'Alameda'\nUsing FIPS code '081' for input 'San Mateo'\nUsing FIPS code '085' for input 'Santa Clara'\nUsing FIPS code '041' for input 'Marin'\nUsing FIPS code '013' for input 'Contra Costa'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-4.png){width=435 height=411}\n:::\n:::\n\n\nWith our tracts in hand, we use the `.merge()` method to merge the\ntabulated LODES data to the Census tract shapes, then make a plot with\n**geopandas**' plotting functionality.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\napple_bay = bay_tracts.merge(apple_commuters, left_on = \"GEOID\", right_on = \"h_tract\")\n\napple_bay.plot(column = 'apple_per_1000', legend = True, \n               cmap = \"cividis\", figsize = (8, 8), \n               k = 7, scheme = \"naturalbreaks\",\n               legend_kwds = {\"loc\": \"lower left\"})\n\nplt.title(\"Apple-area commuters (rate per 1000 total commuters)\\n2019 LODES data, Bay Area Census tracts\", fontsize = 12)\n\nax = plt.gca()\n\nax.set_axis_off()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-1.png){width=614 height=648}\n:::\n:::\n\n\nCommuters to Apple's tract tend to be concentrated around that tract;\nhowever, several neighborhoods in San Francisco proper send dozens of\ncommuters per 1000 total commuters south to Cupertino.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}